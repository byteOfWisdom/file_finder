use cursive;
use cursive::CursiveExt;
use cursive::views::{SelectView, LinearLayout, Dialog, EditView};
use cursive::traits::{Nameable, Resizable};

fn main() {
	let mut search_state = SearchState::new();
	let _ = build_interface(&mut search_state);
}


#[derive(Debug)]
struct SearchState {
	request : String,
	results : Vec<String>,
}

impl SearchState {
	pub fn new() -> Self {
		return SearchState {
			request : String::new(),
			results : Vec::new(),
		}
	}

	pub 

}




fn build_interface(search_state : &mut SearchState) -> cursive::Cursive{
	let mut interface = cursive::Cursive::default();

	fn update_search(s : &mut cursive::Cursive, search : &str, len : usize) {
		//run search on the current request (maybe think of a smart way to only look for the diffs)

		//display the results
		search_state.

		return;
	}

	//quit callback
	interface.add_global_callback(cursive::event::Key::Esc, |s| s.quit());


	let input = Dialog::around(
			EditView::new()
			.on_edit(update_search)
			.with_name("search string")
		)
		.title("search string")
		.fixed_width(80);


	let select = SelectView::<String>::new()
		.with_name("results");

	let app_layout = LinearLayout::vertical()
		.child(input)
		.child(select);


	interface.add_layer(app_layout);

	interface.run();
	return interface;
}